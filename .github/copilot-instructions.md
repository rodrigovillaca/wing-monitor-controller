# Wing Monitor Controller - Copilot Instructions

This document provides context and guidelines for working on the Wing Monitor Controller project.

## 1. Project Overview & Architecture

*   **Type**: Nx Monorepo
*   **Goal**: Web-based monitor controller for Behringer Wing console via OSC.
*   **Structure**:
    *   `apps/web-client`: React 19 + Vite frontend.
    *   `apps/api`: Node.js + Express + WebSocket backend.
    *   `libs/wing-controller`: Core logic for OSC communication (Behringer Wing specific).
    *   `libs/monitor-backend`: Backend logic including settings management and server setup.
    *   `libs/monitor-frontend`: Frontend logic including state management hooks.
    *   `libs/shared-models`: Shared TypeScript interfaces and types (DTOs).

## 2. Collaboration Model: Manus AI + Human Developer

This project is developed through an asynchronous collaboration between **Manus AI** (autonomous agent) and **Human Developers**.

*   **Manus AI Role**: Handles architectural restructuring, boilerplate generation, complex refactoring, and initial implementation of core logic. Manus operates in a sandbox and pushes to GitHub.
*   **Human Developer Role**: Uses VS Code with GitHub Copilot to refine UI/UX, implement specific business logic, debug, and perform final integration.
*   **Copilot's Role**: You are the bridge. You must understand the code generated by Manus and help the human developer extend it without breaking the established patterns.

**Key Collaboration Rules for Copilot:**
1.  **Respect Existing Patterns**: Manus has established specific patterns (e.g., Neomorphic UI, Nx library structure). Do not suggest code that deviates from these unless explicitly asked.
2.  **Explain Changes**: When suggesting a refactor of Manus-generated code, explain *why* (e.g., "Optimizing the `useEffect` hook generated by Manus to prevent unnecessary re-renders").
3.  **Context Awareness**: Be aware that some files may have been generated programmatically. Look for comments or structures that indicate this.

## 3. Technology Stack

*   **Language**: TypeScript (Strict mode enabled).
*   **Frontend**: React 19, Vite, Wouter (routing), Tailwind CSS (v4).
*   **Backend**: Node.js, Express, `ws` (WebSocket), `node-osc`.
*   **Testing**: Jest, React Testing Library.
*   **Package Manager**: pnpm.

## 4. Coding Standards & Best Practices

### TypeScript
*   **Strict Typing**: Never use `any`. Define interfaces in `libs/shared-models` if shared, or locally if private.
*   **Explicit Returns**: Always specify return types for functions, especially API handlers and hooks.
*   **Enums vs Unions**: Prefer string union types over Enums for better serialization.

### React (Frontend)
*   **Components**: Use Functional Components with Hooks.
*   **State**: Use `useMonitorController` hook for all Wing-related state. Implement optimistic updates for UI responsiveness.
*   **Styling**: Use Tailwind CSS 4.
    *   **Neomorphism**: This project uses a specific Neomorphic design language.
    *   Use `neu-flat`, `neu-pressed`, and `neu-convex` utility classes for depth.
    *   Use `font-rajdhani` for headers and technical text.
    *   **Do not** introduce new colors without checking `tailwind.config.js` or `index.css` variables.
*   **Performance**: Memoize expensive calculations with `useMemo` and callbacks with `useCallback`.

### Node.js (Backend)
*   **Async/Await**: Use `async/await` for asynchronous operations.
*   **Configuration**:
    *   Settings are stored in `~/.monitor-controller-settings`.
    *   Use `libs/monitor-backend/src/lib/settings.ts` for loading/saving.
    *   **Never** hardcode IP addresses or paths; use the configuration object.
*   **WebSockets**:
    *   Use typed messages defined in `libs/shared-models`.
    *   Always handle connection errors and disconnections gracefully.
*   **OSC**:
    *   Encapsulate OSC logic within `libs/wing-controller`.
    *   Do not leak OSC library details to the API layer; use the abstraction.

### Testing
*   **Framework**: Jest.
*   **Requirement**: Every new component or logic function MUST have a corresponding `.spec.ts` or `.spec.tsx` file.
*   **Pattern**:
    *   **Unit**: Test individual functions and components in isolation.
    *   **Integration**: Test the interaction between the API and the Wing Controller library.

## 5. Specific Patterns & Examples

### Shared Models
When defining a new message type for WebSocket communication, add it to `libs/shared-models/src/lib/shared-models.ts`:

```typescript
// Example
export interface MonitorState {
  mainLevel: number; // 0-100
  isMuted: boolean;
  isDimmed: boolean;
  activeInputIndex: number;
}
```

### Neomorphic Button Component
When generating UI components, follow this style:

```tsx
// Example of Neomorphic style
<NeuButton
  label="TALK"
  active={state.isTalkbackEnabled}
  onClick={() => updateState({ isTalkbackEnabled: !state.isTalkbackEnabled })}
  className="w-24 h-24 rounded-full"
  ledColor="red"
  icon={<Mic2 />}
/>
```

### OSC Command Construction
When adding new Wing commands in `libs/wing-controller`:

```typescript
// Example
public setVolume(level: number): void {
  // Level must be float 0.0 - 1.0
  this.sendOSC(this.config.monitorMain.path + '/fader', level / 100);
}
```

## 6. Git Workflow

*   **Authentication**: Use `gh` CLI for authentication.
*   **Commits**: Follow Conventional Commits (e.g., `feat:`, `fix:`, `docs:`).
*   **Pushing**: Always pull before pushing.

## 7. Important Context

*   **Mock Mode**: The app supports a Mock Mode (`VITE_MOCK_MODE=true`) for development without a physical console.
*   **Settings**: The settings modal allows configuring the Wing IP, ports, and channel paths.
*   **Subwoofer**: Subwoofer control is handled via a specific matrix path and trim setting.

## 8. Common Tasks

*   **Adding a new setting**:
    1.  Update `WingMonitorConfig` in `libs/shared-models`.
    2.  Update `SettingsModal.tsx` to add the UI field.
    3.  Update `settings.ts` default values.
    4.  Update `useMonitorController.ts` mock data.

*   **Adding a new command**:
    1.  Add command type to `handleClientMessage` in `monitor-backend.ts`.
    2.  Add method to `WingMonitorController` class.
    3.  Add frontend wrapper in `useMonitorController.ts`.
